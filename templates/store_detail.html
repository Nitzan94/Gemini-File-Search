{% extends "base.html" %}

{% block title %}Store Detail - Gemini File Search{% endblock %}

{% block content %}
<div style="margin-bottom: 20px;">
    <button class="btn btn-secondary" onclick="window.location.href='/'">Back to Dashboard</button>
</div>

<div id="store-info" class="card mb-20">
    <div class="loading">Loading store info...</div>
</div>

<div class="card mb-20">
    <h2>Upload Files</h2>
    <div class="drop-zone" id="drop-zone">
        <p>Drag & drop files here or click to select</p>
        <input type="file" id="file-input" multiple style="display: none;">
    </div>
    <div id="upload-progress" style="margin-top: 15px;"></div>
</div>

<div class="card mb-20">
    <h2>Chat with Your Documents</h2>
    <div class="chat-container">
        <div class="chat-messages" id="chat-messages">
            <div class="welcome-message">
                <p>Ask me anything about your documents...</p>
            </div>
        </div>
        <div class="chat-input-container">
            <textarea id="chat-input" placeholder="Type your question..." rows="1"></textarea>
            <button class="btn btn-primary" id="send-btn" onclick="sendMessage()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </button>
        </div>
    </div>
</div>

<div class="card">
    <h2>Documents</h2>
    <div id="documents-list" hx-get="/api/stores/{{ store_id }}/documents" hx-trigger="load, documentUploaded from:body" hx-swap="innerHTML">
        <div class="loading">Loading documents...</div>
    </div>
</div>

<script>
const storeId = '{{ store_id }}';

// Load store info
async function loadStoreInfo() {
    try {
        const response = await fetch(`/api/stores/${storeId}`);
        const store = await response.json();

        const container = document.getElementById('store-info');
        const storeName = store.name.split('/')[1];

        container.innerHTML = `
            <h2>${store.display_name || storeName}</h2>
            <div style="margin: 10px 0;">
                <span class="metric"><strong>${store.active_documents_count}</strong> active</span>
                <span class="metric"><strong>${store.pending_documents_count}</strong> pending</span>
                <span class="metric"><strong>${store.failed_documents_count}</strong> failed</span>
                <span class="metric"><strong>${formatBytes(store.size_bytes)}</strong></span>
            </div>
            <p style="color: #5f6368; font-size: 13px;">${store.name}</p>
        `;
    } catch (error) {
        document.getElementById('store-info').innerHTML = `<p style="color: #ea4335;">Error loading store: ${error.message}</p>`;
    }
}

// Drag and drop
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');

dropZone.addEventListener('click', () => fileInput.click());

dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('drag-over');
});

dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('drag-over');
});

dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('drag-over');
    handleFiles(e.dataTransfer.files);
});

fileInput.addEventListener('change', (e) => {
    handleFiles(e.target.files);
});

async function handleFiles(files) {
    const progressDiv = document.getElementById('upload-progress');
    progressDiv.innerHTML = '';

    for (const file of files) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('display_name', file.name);

        const progressItem = document.createElement('div');
        progressItem.className = 'list-item';
        progressItem.textContent = `Uploading ${file.name}...`;
        progressDiv.appendChild(progressItem);

        try {
            const response = await fetch(`/api/stores/${storeId}/upload`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const result = await response.json();
                progressItem.innerHTML = `<span style="color: #137333;">[OK]</span> ${file.name} - ${result.message}`;

                // Poll operation status
                if (result.operation_name) {
                    pollOperation(result.operation_name, progressItem, file.name);
                }
            } else {
                const error = await response.json();
                progressItem.innerHTML = `<span style="color: #ea4335;">[ERROR]</span> ${file.name} - ${error.detail}`;
            }
        } catch (error) {
            progressItem.innerHTML = `<span style="color: #ea4335;">[ERROR]</span> ${file.name} - ${error.message}`;
        }
    }

    fileInput.value = '';
}

async function pollOperation(operationName, progressItem, fileName) {
    const opId = operationName.split('/').pop();

    const interval = setInterval(async () => {
        try {
            const response = await fetch(`/api/stores/operations/${encodeURIComponent(operationName)}`);
            const operation = await response.json();

            if (operation.done) {
                clearInterval(interval);
                progressItem.innerHTML = `<span style="color: #137333;">[OK]</span> ${fileName} - Upload complete`;
                document.body.dispatchEvent(new Event('documentUploaded'));
            }
        } catch (error) {
            clearInterval(interval);
            progressItem.innerHTML = `<span style="color: #ea4335;">[ERROR]</span> ${fileName} - Status check failed`;
        }
    }, 2000);
}

// Chat functionality
async function sendMessage() {
    const input = document.getElementById('chat-input');
    const query = input.value.trim();

    if (!query) return;

    const messagesContainer = document.getElementById('chat-messages');
    const sendBtn = document.getElementById('send-btn');

    // Remove welcome message if exists
    const welcomeMsg = messagesContainer.querySelector('.welcome-message');
    if (welcomeMsg) {
        welcomeMsg.remove();
    }

    // Add user message
    addMessage('user', query);

    // Clear input and disable button
    input.value = '';
    input.style.height = 'auto';
    sendBtn.disabled = true;

    // Show typing indicator
    const typingId = addTypingIndicator();

    try {
        const response = await fetch('/api/query', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                query: query,
                store_ids: [storeId]
            })
        });

        // Remove typing indicator
        removeTypingIndicator(typingId);

        if (response.ok) {
            const result = await response.json();
            addMessage('ai', result.text || 'No answer found', result.citations);
        } else {
            const error = await response.json();
            addMessage('ai', `Error: ${error.detail}`, null, true);
        }
    } catch (error) {
        removeTypingIndicator(typingId);
        addMessage('ai', `Error: ${error.message}`, null, true);
    } finally {
        sendBtn.disabled = false;
        input.focus();
    }
}

function addMessage(type, text, citations = null, isError = false) {
    const messagesContainer = document.getElementById('chat-messages');

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';

    // Format text with line breaks
    const paragraphs = text.split('\n').filter(p => p.trim());
    paragraphs.forEach(para => {
        const p = document.createElement('p');
        p.textContent = para;
        contentDiv.appendChild(p);
    });

    // Add citations if present
    if (citations && citations.length > 0) {
        const citationsDiv = document.createElement('div');
        citationsDiv.className = 'message-citations';
        citationsDiv.innerHTML = '<strong>Sources:</strong>';

        citations.forEach((citation, index) => {
            const citItem = document.createElement('div');
            citItem.className = 'citation-item';
            citItem.innerHTML = `[${index + 1}] ${citation.title || 'Source'}${
                citation.uri ? ` - <a href="${citation.uri}" target="_blank">View</a>` : ''
            }`;
            citationsDiv.appendChild(citItem);
        });

        contentDiv.appendChild(citationsDiv);
    }

    messageDiv.appendChild(contentDiv);
    messagesContainer.appendChild(messageDiv);

    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function addTypingIndicator() {
    const messagesContainer = document.getElementById('chat-messages');

    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ai';
    messageDiv.id = 'typing-indicator';

    const typingDiv = document.createElement('div');
    typingDiv.className = 'typing-indicator';
    typingDiv.innerHTML = '<span></span><span></span><span></span>';

    messageDiv.appendChild(typingDiv);
    messagesContainer.appendChild(messageDiv);

    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    return 'typing-indicator';
}

function removeTypingIndicator(id) {
    const indicator = document.getElementById(id);
    if (indicator) {
        indicator.remove();
    }
}

// Auto-resize textarea
document.getElementById('chat-input').addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
});

// Send on Enter (Shift+Enter for new line)
document.getElementById('chat-input').addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

async function deleteDocument(docName) {
    if (!confirm('Delete this document?')) {
        return;
    }

    const parts = docName.split('/');
    const docId = parts[parts.length - 1];

    try {
        const response = await fetch(`/api/stores/${storeId}/documents/${docId}`, {
            method: 'DELETE'
        });

        if (response.ok) {
            document.body.dispatchEvent(new Event('documentUploaded'));
        } else {
            const error = await response.json();
            alert('Error: ' + error.detail);
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// HTMX after-swap
document.addEventListener('htmx:afterSwap', function(event) {
    if (event.detail.target.id === 'documents-list') {
        renderDocuments(event.detail.xhr.response);
    }
});

function renderDocuments(responseText) {
    const data = JSON.parse(responseText);
    const container = document.getElementById('documents-list');

    if (!data.documents || data.documents.length === 0) {
        container.innerHTML = '<p style="color: #5f6368;">No documents yet. Upload some files to get started.</p>';
        return;
    }

    container.innerHTML = data.documents.map(doc => {
        const docId = doc.name.split('/').pop();
        let badge = '';

        if (doc.state === 'STATE_ACTIVE') {
            badge = '<span class="badge badge-success">ACTIVE</span>';
        } else if (doc.state === 'STATE_PENDING') {
            badge = '<span class="badge badge-warning">PENDING</span>';
        } else if (doc.state === 'STATE_FAILED') {
            badge = '<span class="badge badge-danger">FAILED</span>';
        }

        const metadata = doc.custom_metadata && doc.custom_metadata.length > 0
            ? doc.custom_metadata.map(m => `${m.key}: ${m.value}`).join(', ')
            : '';

        return `
            <div class="list-item">
                <div class="flex">
                    <div>
                        <div style="margin-bottom: 5px;">
                            <strong>${doc.display_name}</strong>
                            ${badge}
                        </div>
                        <div style="color: #5f6368; font-size: 13px;">
                            ${formatBytes(doc.size_bytes)} • ${doc.mime_type || 'Unknown type'}
                            ${metadata ? ` • ${metadata}` : ''}
                        </div>
                    </div>
                    <button class="btn btn-danger" onclick="deleteDocument('${doc.name}')">
                        Delete
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// Load store info on page load
loadStoreInfo();
</script>
{% endblock %}
